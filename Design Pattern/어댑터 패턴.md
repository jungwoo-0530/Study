## 어댑터 패턴

> 패턴 소개

\- 말 그대로 어댑터 역할을 한다

- 어댑터는 말 그대로 usb to c 어댑터 처럼 **서로 호환이 안되는 것을 가능하게함**.
- 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.

\- 기존 코드를 클라이언트가 사용하는 인터페이스의 구현체로 바꿔주는 패턴

\- 클라이언트가 사용하는 인터페이스를 따르지 않는 기존코드를 재사용 할 수 있게 해준다.

\- 별도의 클래스 생성하기와 인터페이스 상속받아 구현하기 방법이 있다.

\- OCP 및 SRP와 관련된 패턴

\- 장점

 \> 기존 코드를 변경하지 않고 원하는 인터페이스 구현체를 만들어 재사용 할 수 있다.

 \> 기존 코드가 하던 일과 특정 인터페이스 구현체를 변환하는 작업을 각기 다른 클래스로 분리하여 관리할 수 있다.
\- 단점

 \> 새 클래스가 생겨 복잡도가 증가할 수 있다. 경우에 따라서는 기존코드가 해당 인터페이스를 구현하도록 하자.

<img src="img/어댑터 패턴/image-20220905010815939.png" alt="image-20220905010815939" style="zoom:50%;" />

<img src="img/어댑터 패턴/image-20220905010856507.png" alt="image-20220905010856507" style="zoom:50%;" />

<img src="img/어댑터 패턴/image-20220906030521666.png" alt="image-20220906030521666" style="zoom:50%;" />









## 언제 사용?



**어댑터 패턴의 Key Point는 기존 메인로직을 변경하지 않고 새로운 것(확장)을 받아들인다.**



**시나리오 : 기존 회원 서비스로직이 존재하는 상태에서, 스프링 시큐리티 프레임워크를 추가하여 시큐리티로 계정 로그인을 구현하려는 상황**

- 기존 회원 서비스 로직 - Adaptee
  - `Account`
  - `AccountService`
  - `LoginHandler` - Client
- 스프링 시큐리티 프레임워크를 추가. - Adapter
  - `UserDetailsService`
  - `UserDetails`



`LoginHandler class`는 코드 변경없이 그대로 `UserDetails와 UserDetailService` 인터페이스만 의존하면서도

기존에 존재하던 `Account와 AccountService`를 어댑터 안에서 사용하는 호환성을 보여준다.













> 자바와 스프링에서 찾아보는 패턴

\- Array.asList

\- Collections.enumeration

\- Collections.list

\- 스프링 MVC Handler Adaptor







# 다른 패턴과의 관계

- 브릿지패턴은 두 종류의 코드가 서로 독립적으로 개발될수 있게끔 사전에 설계하는 편이지만, 어댑터 패턴은 기존에 존재하던 코드에 추가로 다른 코드를 호환할때 사용되는 편이다.
- 어댑터 패턴을 `Object Adapter`로 사용할 경우 래핑하는 방식으로 구현이 되는데, 이때의 패턴 의도는(`Intend`) 다른 인터페이스로 변환하기 위함이다. 반면 프록시 패턴은 같은 인터페이스를 그대로 사용하며, 데코레이터 패턴은 인터페이스를 추가한다는 점에서 차이가 존재한다.
- 파사드 패턴(`Facade`)은 기존에 존재하는 객체에 인터페이스를 새로 정의한다는 점에서 어댑터 패턴과 차이가 있으며, 어댑터 패턴은 하나의 객체만 래핑하지만 파사드 패턴은 서브시스템의 전체 객체에 대해 작동한다는 점에서 차이가 있다.
- 브릿지, 스테이트, 전략, 어댑터 패턴은 서로 상당히 비슷한 구조를 띈다. 그러나 해결하려는 문제와 의도가 다르다는점을 명심하자. 디자인 패턴은 코드의 구조가 핵심이 아니라, 특정 문제와 그 문제 해결하려는 의도가 핵심이다!





https://www.jiniaslog.co.kr/article/view?articleId=806